{"ast":null,"code":"import { defaultLocale } from \"./_lib/defaultLocale.mjs\";\nimport { getDefaultOptions } from \"./_lib/defaultOptions.mjs\";\nimport { getRoundingMethod } from \"./_lib/getRoundingMethod.mjs\";\nimport { getTimezoneOffsetInMilliseconds } from \"./_lib/getTimezoneOffsetInMilliseconds.mjs\";\nimport { compareAsc } from \"./compareAsc.mjs\";\nimport { millisecondsInMinute, minutesInDay, minutesInMonth, minutesInYear } from \"./constants.mjs\";\nimport { toDate } from \"./toDate.mjs\";\n\n/**\r\n * The {@link formatDistanceStrict} function options.\r\n */\n\n/**\r\n * The unit used to format the distance in {@link formatDistanceStrict}.\r\n */\n\n/**\r\n * @name formatDistanceStrict\r\n * @category Common Helpers\r\n * @summary Return the distance between the given dates in words.\r\n *\r\n * @description\r\n * Return the distance between the given dates in words, using strict units.\r\n * This is like `formatDistance`, but does not use helpers like 'almost', 'over',\r\n * 'less than' and the like.\r\n *\r\n * | Distance between dates | Result              |\r\n * |------------------------|---------------------|\r\n * | 0 ... 59 secs          | [0..59] seconds     |\r\n * | 1 ... 59 mins          | [1..59] minutes     |\r\n * | 1 ... 23 hrs           | [1..23] hours       |\r\n * | 1 ... 29 days          | [1..29] days        |\r\n * | 1 ... 11 months        | [1..11] months      |\r\n * | 1 ... N years          | [1..N]  years       |\r\n *\r\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\r\n *\r\n * @param date - The date\r\n * @param baseDate - The date to compare with\r\n * @param options - An object with options\r\n *\r\n * @returns The distance in words\r\n *\r\n * @throws `date` must not be Invalid Date\r\n * @throws `baseDate` must not be Invalid Date\r\n * @throws `options.unit` must be 'second', 'minute', 'hour', 'day', 'month' or 'year'\r\n * @throws `options.locale` must contain `formatDistance` property\r\n *\r\n * @example\r\n * // What is the distance between 2 July 2014 and 1 January 2015?\r\n * const result = formatDistanceStrict(new Date(2014, 6, 2), new Date(2015, 0, 2))\r\n * //=> '6 months'\r\n *\r\n * @example\r\n * // What is the distance between 1 January 2015 00:00:15\r\n * // and 1 January 2015 00:00:00?\r\n * const result = formatDistanceStrict(\r\n *   new Date(2015, 0, 1, 0, 0, 15),\r\n *   new Date(2015, 0, 1, 0, 0, 0)\r\n * )\r\n * //=> '15 seconds'\r\n *\r\n * @example\r\n * // What is the distance from 1 January 2016\r\n * // to 1 January 2015, with a suffix?\r\n * const result = formatDistanceStrict(new Date(2015, 0, 1), new Date(2016, 0, 1), {\r\n *   addSuffix: true\r\n * })\r\n * //=> '1 year ago'\r\n *\r\n * @example\r\n * // What is the distance from 1 January 2016\r\n * // to 1 January 2015, in minutes?\r\n * const result = formatDistanceStrict(new Date(2016, 0, 1), new Date(2015, 0, 1), {\r\n *   unit: 'minute'\r\n * })\r\n * //=> '525600 minutes'\r\n *\r\n * @example\r\n * // What is the distance from 1 January 2015\r\n * // to 28 January 2015, in months, rounded up?\r\n * const result = formatDistanceStrict(new Date(2015, 0, 28), new Date(2015, 0, 1), {\r\n *   unit: 'month',\r\n *   roundingMethod: 'ceil'\r\n * })\r\n * //=> '1 month'\r\n *\r\n * @example\r\n * // What is the distance between 1 August 2016 and 1 January 2015 in Esperanto?\r\n * import { eoLocale } from 'date-fns/locale/eo'\r\n * const result = formatDistanceStrict(new Date(2016, 7, 1), new Date(2015, 0, 1), {\r\n *   locale: eoLocale\r\n * })\r\n * //=> '1 jaro'\r\n */\n\nexport function formatDistanceStrict(date, baseDate, options) {\n  const defaultOptions = getDefaultOptions();\n  const locale = options?.locale ?? defaultOptions.locale ?? defaultLocale;\n  const comparison = compareAsc(date, baseDate);\n  if (isNaN(comparison)) {\n    throw new RangeError(\"Invalid time value\");\n  }\n  const localizeOptions = Object.assign({}, options, {\n    addSuffix: options?.addSuffix,\n    comparison: comparison\n  });\n  let dateLeft;\n  let dateRight;\n  if (comparison > 0) {\n    dateLeft = toDate(baseDate);\n    dateRight = toDate(date);\n  } else {\n    dateLeft = toDate(date);\n    dateRight = toDate(baseDate);\n  }\n  const roundingMethod = getRoundingMethod(options?.roundingMethod ?? \"round\");\n  const milliseconds = dateRight.getTime() - dateLeft.getTime();\n  const minutes = milliseconds / millisecondsInMinute;\n  const timezoneOffset = getTimezoneOffsetInMilliseconds(dateRight) - getTimezoneOffsetInMilliseconds(dateLeft);\n\n  // Use DST-normalized difference in minutes for years, months and days;\n  // use regular difference in minutes for hours, minutes and seconds.\n  const dstNormalizedMinutes = (milliseconds - timezoneOffset) / millisecondsInMinute;\n  const defaultUnit = options?.unit;\n  let unit;\n  if (!defaultUnit) {\n    if (minutes < 1) {\n      unit = \"second\";\n    } else if (minutes < 60) {\n      unit = \"minute\";\n    } else if (minutes < minutesInDay) {\n      unit = \"hour\";\n    } else if (dstNormalizedMinutes < minutesInMonth) {\n      unit = \"day\";\n    } else if (dstNormalizedMinutes < minutesInYear) {\n      unit = \"month\";\n    } else {\n      unit = \"year\";\n    }\n  } else {\n    unit = defaultUnit;\n  }\n\n  // 0 up to 60 seconds\n  if (unit === \"second\") {\n    const seconds = roundingMethod(milliseconds / 1000);\n    return locale.formatDistance(\"xSeconds\", seconds, localizeOptions);\n\n    // 1 up to 60 mins\n  } else if (unit === \"minute\") {\n    const roundedMinutes = roundingMethod(minutes);\n    return locale.formatDistance(\"xMinutes\", roundedMinutes, localizeOptions);\n\n    // 1 up to 24 hours\n  } else if (unit === \"hour\") {\n    const hours = roundingMethod(minutes / 60);\n    return locale.formatDistance(\"xHours\", hours, localizeOptions);\n\n    // 1 up to 30 days\n  } else if (unit === \"day\") {\n    const days = roundingMethod(dstNormalizedMinutes / minutesInDay);\n    return locale.formatDistance(\"xDays\", days, localizeOptions);\n\n    // 1 up to 12 months\n  } else if (unit === \"month\") {\n    const months = roundingMethod(dstNormalizedMinutes / minutesInMonth);\n    return months === 12 && defaultUnit !== \"month\" ? locale.formatDistance(\"xYears\", 1, localizeOptions) : locale.formatDistance(\"xMonths\", months, localizeOptions);\n\n    // 1 year up to max Date\n  } else {\n    const years = roundingMethod(dstNormalizedMinutes / minutesInYear);\n    return locale.formatDistance(\"xYears\", years, localizeOptions);\n  }\n}\n\n// Fallback for modularized imports:\nexport default formatDistanceStrict;","map":{"version":3,"names":["defaultLocale","getDefaultOptions","getRoundingMethod","getTimezoneOffsetInMilliseconds","compareAsc","millisecondsInMinute","minutesInDay","minutesInMonth","minutesInYear","toDate","formatDistanceStrict","date","baseDate","options","defaultOptions","locale","comparison","isNaN","RangeError","localizeOptions","Object","assign","addSuffix","dateLeft","dateRight","roundingMethod","milliseconds","getTime","minutes","timezoneOffset","dstNormalizedMinutes","defaultUnit","unit","seconds","formatDistance","roundedMinutes","hours","days","months","years"],"sources":["C:/Users/Storm/Desktop/SE104/MERN-tutorial/MERN-Getting-Started/frontend/node_modules/date-fns/formatDistanceStrict.mjs"],"sourcesContent":["import { defaultLocale } from \"./_lib/defaultLocale.mjs\";\r\nimport { getDefaultOptions } from \"./_lib/defaultOptions.mjs\";\r\nimport { getRoundingMethod } from \"./_lib/getRoundingMethod.mjs\";\r\nimport { getTimezoneOffsetInMilliseconds } from \"./_lib/getTimezoneOffsetInMilliseconds.mjs\";\r\nimport { compareAsc } from \"./compareAsc.mjs\";\r\nimport {\r\n  millisecondsInMinute,\r\n  minutesInDay,\r\n  minutesInMonth,\r\n  minutesInYear,\r\n} from \"./constants.mjs\";\r\nimport { toDate } from \"./toDate.mjs\";\r\n\r\n/**\r\n * The {@link formatDistanceStrict} function options.\r\n */\r\n\r\n/**\r\n * The unit used to format the distance in {@link formatDistanceStrict}.\r\n */\r\n\r\n/**\r\n * @name formatDistanceStrict\r\n * @category Common Helpers\r\n * @summary Return the distance between the given dates in words.\r\n *\r\n * @description\r\n * Return the distance between the given dates in words, using strict units.\r\n * This is like `formatDistance`, but does not use helpers like 'almost', 'over',\r\n * 'less than' and the like.\r\n *\r\n * | Distance between dates | Result              |\r\n * |------------------------|---------------------|\r\n * | 0 ... 59 secs          | [0..59] seconds     |\r\n * | 1 ... 59 mins          | [1..59] minutes     |\r\n * | 1 ... 23 hrs           | [1..23] hours       |\r\n * | 1 ... 29 days          | [1..29] days        |\r\n * | 1 ... 11 months        | [1..11] months      |\r\n * | 1 ... N years          | [1..N]  years       |\r\n *\r\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\r\n *\r\n * @param date - The date\r\n * @param baseDate - The date to compare with\r\n * @param options - An object with options\r\n *\r\n * @returns The distance in words\r\n *\r\n * @throws `date` must not be Invalid Date\r\n * @throws `baseDate` must not be Invalid Date\r\n * @throws `options.unit` must be 'second', 'minute', 'hour', 'day', 'month' or 'year'\r\n * @throws `options.locale` must contain `formatDistance` property\r\n *\r\n * @example\r\n * // What is the distance between 2 July 2014 and 1 January 2015?\r\n * const result = formatDistanceStrict(new Date(2014, 6, 2), new Date(2015, 0, 2))\r\n * //=> '6 months'\r\n *\r\n * @example\r\n * // What is the distance between 1 January 2015 00:00:15\r\n * // and 1 January 2015 00:00:00?\r\n * const result = formatDistanceStrict(\r\n *   new Date(2015, 0, 1, 0, 0, 15),\r\n *   new Date(2015, 0, 1, 0, 0, 0)\r\n * )\r\n * //=> '15 seconds'\r\n *\r\n * @example\r\n * // What is the distance from 1 January 2016\r\n * // to 1 January 2015, with a suffix?\r\n * const result = formatDistanceStrict(new Date(2015, 0, 1), new Date(2016, 0, 1), {\r\n *   addSuffix: true\r\n * })\r\n * //=> '1 year ago'\r\n *\r\n * @example\r\n * // What is the distance from 1 January 2016\r\n * // to 1 January 2015, in minutes?\r\n * const result = formatDistanceStrict(new Date(2016, 0, 1), new Date(2015, 0, 1), {\r\n *   unit: 'minute'\r\n * })\r\n * //=> '525600 minutes'\r\n *\r\n * @example\r\n * // What is the distance from 1 January 2015\r\n * // to 28 January 2015, in months, rounded up?\r\n * const result = formatDistanceStrict(new Date(2015, 0, 28), new Date(2015, 0, 1), {\r\n *   unit: 'month',\r\n *   roundingMethod: 'ceil'\r\n * })\r\n * //=> '1 month'\r\n *\r\n * @example\r\n * // What is the distance between 1 August 2016 and 1 January 2015 in Esperanto?\r\n * import { eoLocale } from 'date-fns/locale/eo'\r\n * const result = formatDistanceStrict(new Date(2016, 7, 1), new Date(2015, 0, 1), {\r\n *   locale: eoLocale\r\n * })\r\n * //=> '1 jaro'\r\n */\r\n\r\nexport function formatDistanceStrict(date, baseDate, options) {\r\n  const defaultOptions = getDefaultOptions();\r\n  const locale = options?.locale ?? defaultOptions.locale ?? defaultLocale;\r\n\r\n  const comparison = compareAsc(date, baseDate);\r\n\r\n  if (isNaN(comparison)) {\r\n    throw new RangeError(\"Invalid time value\");\r\n  }\r\n\r\n  const localizeOptions = Object.assign({}, options, {\r\n    addSuffix: options?.addSuffix,\r\n    comparison: comparison,\r\n  });\r\n\r\n  let dateLeft;\r\n  let dateRight;\r\n  if (comparison > 0) {\r\n    dateLeft = toDate(baseDate);\r\n    dateRight = toDate(date);\r\n  } else {\r\n    dateLeft = toDate(date);\r\n    dateRight = toDate(baseDate);\r\n  }\r\n\r\n  const roundingMethod = getRoundingMethod(options?.roundingMethod ?? \"round\");\r\n\r\n  const milliseconds = dateRight.getTime() - dateLeft.getTime();\r\n  const minutes = milliseconds / millisecondsInMinute;\r\n\r\n  const timezoneOffset =\r\n    getTimezoneOffsetInMilliseconds(dateRight) -\r\n    getTimezoneOffsetInMilliseconds(dateLeft);\r\n\r\n  // Use DST-normalized difference in minutes for years, months and days;\r\n  // use regular difference in minutes for hours, minutes and seconds.\r\n  const dstNormalizedMinutes =\r\n    (milliseconds - timezoneOffset) / millisecondsInMinute;\r\n\r\n  const defaultUnit = options?.unit;\r\n  let unit;\r\n  if (!defaultUnit) {\r\n    if (minutes < 1) {\r\n      unit = \"second\";\r\n    } else if (minutes < 60) {\r\n      unit = \"minute\";\r\n    } else if (minutes < minutesInDay) {\r\n      unit = \"hour\";\r\n    } else if (dstNormalizedMinutes < minutesInMonth) {\r\n      unit = \"day\";\r\n    } else if (dstNormalizedMinutes < minutesInYear) {\r\n      unit = \"month\";\r\n    } else {\r\n      unit = \"year\";\r\n    }\r\n  } else {\r\n    unit = defaultUnit;\r\n  }\r\n\r\n  // 0 up to 60 seconds\r\n  if (unit === \"second\") {\r\n    const seconds = roundingMethod(milliseconds / 1000);\r\n    return locale.formatDistance(\"xSeconds\", seconds, localizeOptions);\r\n\r\n    // 1 up to 60 mins\r\n  } else if (unit === \"minute\") {\r\n    const roundedMinutes = roundingMethod(minutes);\r\n    return locale.formatDistance(\"xMinutes\", roundedMinutes, localizeOptions);\r\n\r\n    // 1 up to 24 hours\r\n  } else if (unit === \"hour\") {\r\n    const hours = roundingMethod(minutes / 60);\r\n    return locale.formatDistance(\"xHours\", hours, localizeOptions);\r\n\r\n    // 1 up to 30 days\r\n  } else if (unit === \"day\") {\r\n    const days = roundingMethod(dstNormalizedMinutes / minutesInDay);\r\n    return locale.formatDistance(\"xDays\", days, localizeOptions);\r\n\r\n    // 1 up to 12 months\r\n  } else if (unit === \"month\") {\r\n    const months = roundingMethod(dstNormalizedMinutes / minutesInMonth);\r\n    return months === 12 && defaultUnit !== \"month\"\r\n      ? locale.formatDistance(\"xYears\", 1, localizeOptions)\r\n      : locale.formatDistance(\"xMonths\", months, localizeOptions);\r\n\r\n    // 1 year up to max Date\r\n  } else {\r\n    const years = roundingMethod(dstNormalizedMinutes / minutesInYear);\r\n    return locale.formatDistance(\"xYears\", years, localizeOptions);\r\n  }\r\n}\r\n\r\n// Fallback for modularized imports:\r\nexport default formatDistanceStrict;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}